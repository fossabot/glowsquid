// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::{
  bigdecimal::{self, FromPrimitive},
  chrono,
  datamodel::parse_configuration,
  operator::Operator,
  prisma_models::{InternalDataModelBuilder, PrismaValue},
  queries::{QueryContext, QueryInfo, Result as QueryResult},
  query_core::{
    executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
    QueryGraphBuilderError, QuerySchema, QueryValue, Selection,
  },
  serde_json, transform_equals, BatchResult, Direction, ManyArgs, SerializedWhere,
  SerializedWhereValue, UniqueArgs,
};
pub use prisma_client_rust::{queries::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::{path::Path, sync::Arc};
static DATAMODEL_STR : & 'static str = "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"cargo prisma\"\n  output   = \"../src/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = \"file:dev.db\"\n}\n\n/// A minecraft account\nmodel Account {\n  /// The account's unique id\n  id            String   @id\n  /// The account's username\n  username      String   @unique\n  /// The account's access token. To be refreshed when expired\n  accessToken   String\n  /// The account's refresh token. To be used to refresh the access token\n  refreshToken  String\n  /// The time the access token expires. If this is in the past, the access token needs to be refreshed\n  expiresAt     DateTime\n  /// The last time the access token was refreshed\n  lastRefreshed DateTime @updatedAt\n}\n\n/// A modpack\nmodel Modpack {\n  /// The modpack's id.\n  modpackId         String\n  /// The adapter associated with this modpack.\n  adapter           String\n  /// The modpack's name.\n  name              String\n  /// The path on the filesystem to the modpack's root directory.\n  path              String\n  /// The modpack's version.\n  version           String\n  /// URL to the icon for this modpack.\n  iconUrl           String\n  /// The modpack's description. Can be HTML or Markdown\n  description       String\n  /// The modpack's description format.\n  descriptionFormat String\n  /// A short description of the modpack in plaintext\n  shortDescription  String\n  /// The modpack's author.\n  author            String\n  mods              ModsInModpack[]\n\n  @@id([modpackId, adapter])\n}\n\nmodel MinecraftMod {\n  /// The mod's id.\n  modId             String          @map(\"modid\")\n  /// The mod's adapter\n  adapter           String\n  /// The mod's name.\n  name              String\n  /// The mod's version. Should be semver compliant.\n  version           String\n  /// The name of the mod file that is in the cache\n  file              String\n  /// The mod's description. Can be HTML or Markdown\n  description       String\n  /// The mod's description format.\n  descriptionFormat String\n  /// A short description of the mod in plaintext\n  shortDescription  String\n  /// The mod's author.\n  author            String\n  /// The modpacks this mod is in\n  modpack           ModsInModpack[]\n\n  @@id([modId, adapter])\n  @@map(\"Mod\")\n}\n\nmodel ModsInModpack {\n  minecraftMod MinecraftMod @relation(fields: [modId, modAdapter], references: [modId, adapter])\n  modId        String\n  modAdapter   String\n\n  Modpack        Modpack @relation(fields: [modpackId, modpackAdapter], references: [modpackId, adapter])\n  modpackId      String\n  modpackAdapter String\n\n  @@id([modpackId, modId])\n}\n" ;
static DATABASE_STR: &'static str = "sqlite";
pub async fn new_client() -> Result<_prisma::PrismaClient, NewClientError> {
  let config = parse_configuration(DATAMODEL_STR)?.subject;
  let source = config
    .datasources
    .first()
    .expect("Pleasy supply a datasource in your schema.prisma file");
  let url = if let Some(url) = source.load_shadow_database_url()? {
    url
  } else {
    source.load_url(|key| std::env::var(key).ok())?
  };
  let url = if url.starts_with("file:") {
    let path = url.split(":").nth(1).unwrap();
    if Path::new("./schema.prisma").exists() {
      url
    } else if Path::new("./prisma/schema.prisma").exists() {
      format!("file:./prisma/{}", path)
    } else {
      url
    }
  } else {
    url
  };
  new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<_prisma::PrismaClient, NewClientError> {
  let config = parse_configuration(DATAMODEL_STR)?.subject;
  let source = config
    .datasources
    .first()
    .expect("Pleasy supply a datasource in your schema.prisma file");
  let (db_name, executor) = executor::load(&source, &[], &url).await?;
  let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
  let query_schema = Arc::new(schema_builder::build(
    internal_model,
    BuildMode::Modern,
    true,
    source.capabilities(),
    vec![],
    source.referential_integrity(),
  ));
  executor.primary_connector().get_connection().await?;
  Ok(PrismaClient::_new(executor, query_schema))
}
pub mod account {
  use super::{_prisma::*, *};
  pub mod id {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod username {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::UsernameEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Username(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Username(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UsernameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UsernameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::UsernameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::UsernameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::UsernameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::UsernameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::UsernameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::UsernameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::UsernameEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::UsernameNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUsername(value.0)
      }
    }
  }
  pub mod access_token {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::AccessTokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::AccessToken(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AccessTokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AccessTokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AccessTokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AccessTokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AccessTokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AccessTokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AccessTokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AccessTokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AccessTokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AccessTokenNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAccessToken(value.0)
      }
    }
  }
  pub mod refresh_token {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::RefreshTokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::RefreshToken(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::RefreshTokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::RefreshTokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::RefreshTokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::RefreshTokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::RefreshTokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::RefreshTokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::RefreshTokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::RefreshTokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::RefreshTokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::RefreshTokenNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetRefreshToken(value.0)
      }
    }
  }
  pub mod expires_at {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ExpiresAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::ExpiresAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::ExpiresAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetExpiresAt(value.0)
      }
    }
  }
  pub mod last_refreshed {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::LastRefreshedEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::LastRefreshed(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::LastRefreshedInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::LastRefreshedNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::LastRefreshedLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::LastRefreshedLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::LastRefreshedGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::LastRefreshedGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::LastRefreshedNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetLastRefreshed(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    [
      "id",
      "username",
      "accessToken",
      "refreshToken",
      "expiresAt",
      "lastRefreshed",
    ]
    .into_iter()
    .map(|o| {
      let builder = Selection::builder(o);
      builder.build()
    })
    .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "accessToken")]
    pub access_token: String,
    #[serde(rename = "refreshToken")]
    pub refresh_token: String,
    #[serde(rename = "expiresAt")]
    pub expires_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "lastRefreshed")]
    pub last_refreshed: chrono::DateTime<chrono::FixedOffset>,
  }
  impl Data {}
  pub enum WithParam {}
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {}
    }
  }
  pub enum SetParam {
    SetId(String),
    SetUsername(String),
    SetAccessToken(String),
    SetRefreshToken(String),
    SetExpiresAt(chrono::DateTime<chrono::FixedOffset>),
    SetLastRefreshed(chrono::DateTime<chrono::FixedOffset>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
        SetParam::SetUsername(value) => ("username".to_string(), PrismaValue::String(value)),
        SetParam::SetAccessToken(value) => ("accessToken".to_string(), PrismaValue::String(value)),
        SetParam::SetRefreshToken(value) => {
          ("refreshToken".to_string(), PrismaValue::String(value))
        }
        SetParam::SetExpiresAt(value) => ("expiresAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::SetLastRefreshed(value) => {
          ("lastRefreshed".to_string(), PrismaValue::DateTime(value))
        }
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    Username(Direction),
    AccessToken(Direction),
    RefreshToken(Direction),
    ExpiresAt(Direction),
    LastRefreshed(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(direction) => ("id".to_string(), PrismaValue::String(direction.to_string())),
        Self::Username(direction) => (
          "username".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::AccessToken(direction) => (
          "accessToken".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::RefreshToken(direction) => (
          "refreshToken".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::ExpiresAt(direction) => (
          "expiresAt".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::LastRefreshed(direction) => (
          "lastRefreshed".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  pub enum Cursor {
    Id(String),
    Username(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
        Self::Username(cursor) => ("username".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdEquals(String),
    IdInVec(Vec<String>),
    IdNotInVec(Vec<String>),
    IdLt(String),
    IdLte(String),
    IdGt(String),
    IdGte(String),
    IdContains(String),
    IdStartsWith(String),
    IdEndsWith(String),
    IdNot(String),
    UsernameEquals(String),
    UsernameInVec(Vec<String>),
    UsernameNotInVec(Vec<String>),
    UsernameLt(String),
    UsernameLte(String),
    UsernameGt(String),
    UsernameGte(String),
    UsernameContains(String),
    UsernameStartsWith(String),
    UsernameEndsWith(String),
    UsernameNot(String),
    AccessTokenEquals(String),
    AccessTokenInVec(Vec<String>),
    AccessTokenNotInVec(Vec<String>),
    AccessTokenLt(String),
    AccessTokenLte(String),
    AccessTokenGt(String),
    AccessTokenGte(String),
    AccessTokenContains(String),
    AccessTokenStartsWith(String),
    AccessTokenEndsWith(String),
    AccessTokenNot(String),
    RefreshTokenEquals(String),
    RefreshTokenInVec(Vec<String>),
    RefreshTokenNotInVec(Vec<String>),
    RefreshTokenLt(String),
    RefreshTokenLte(String),
    RefreshTokenGt(String),
    RefreshTokenGte(String),
    RefreshTokenContains(String),
    RefreshTokenStartsWith(String),
    RefreshTokenEndsWith(String),
    RefreshTokenNot(String),
    ExpiresAtEquals(chrono::DateTime<chrono::FixedOffset>),
    ExpiresAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    ExpiresAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    ExpiresAtLt(chrono::DateTime<chrono::FixedOffset>),
    ExpiresAtLte(chrono::DateTime<chrono::FixedOffset>),
    ExpiresAtGt(chrono::DateTime<chrono::FixedOffset>),
    ExpiresAtGte(chrono::DateTime<chrono::FixedOffset>),
    ExpiresAtNot(chrono::DateTime<chrono::FixedOffset>),
    LastRefreshedEquals(chrono::DateTime<chrono::FixedOffset>),
    LastRefreshedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    LastRefreshedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    LastRefreshedLt(chrono::DateTime<chrono::FixedOffset>),
    LastRefreshedLte(chrono::DateTime<chrono::FixedOffset>),
    LastRefreshedGt(chrono::DateTime<chrono::FixedOffset>),
    LastRefreshedGte(chrono::DateTime<chrono::FixedOffset>),
    LastRefreshedNot(chrono::DateTime<chrono::FixedOffset>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => (
          "NOT".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::Or(value) => (
          "OR".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::IdEquals(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdInVec(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::IdNotInVec(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::IdLt(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdLte(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdGt(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdGte(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdContains(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdStartsWith(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::IdEndsWith(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::IdNot(value) => (
          "id".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameEquals(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameInVec(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::UsernameNotInVec(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::UsernameLt(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameLte(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameGt(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameGte(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameContains(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameStartsWith(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::UsernameEndsWith(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::UsernameNot(value) => (
          "username".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenEquals(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenInVec(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AccessTokenNotInVec(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AccessTokenLt(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenLte(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenGt(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenGte(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenContains(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenStartsWith(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::AccessTokenEndsWith(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::AccessTokenNot(value) => (
          "accessToken".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenEquals(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenInVec(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::RefreshTokenNotInVec(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::RefreshTokenLt(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenLte(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenGt(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenGte(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenContains(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenStartsWith(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::RefreshTokenEndsWith(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::RefreshTokenNot(value) => (
          "refreshToken".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ExpiresAtEquals(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::ExpiresAtInVec(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::DateTime(v))
                .collect(),
            ),
          )]),
        ),
        Self::ExpiresAtNotInVec(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::DateTime(v))
                .collect(),
            ),
          )]),
        ),
        Self::ExpiresAtLt(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::ExpiresAtLte(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::ExpiresAtGt(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::ExpiresAtGte(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::ExpiresAtNot(value) => (
          "expiresAt".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::LastRefreshedEquals(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::LastRefreshedInVec(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::DateTime(v))
                .collect(),
            ),
          )]),
        ),
        Self::LastRefreshedNotInVec(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::DateTime(v))
                .collect(),
            ),
          )]),
        ),
        Self::LastRefreshedLt(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::LastRefreshedLte(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::LastRefreshedGt(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::LastRefreshedGte(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
        ),
        Self::LastRefreshedNot(value) => (
          "lastRefreshed".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
        ),
      }
    }
  }
  pub enum UniqueWhereParam {
    UsernameEquals(String),
    IdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::UsernameEquals(value) => Self::UsernameEquals(value),
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      id: id::Set,
      username: username::Set,
      access_token: access_token::Set,
      refresh_token: refresh_token::Set,
      expires_at: expires_at::Set,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(id.into());
      _params.push(username.into());
      _params.push(access_token.into());
      _params.push(refresh_token.into());
      _params.push(expires_at.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        _params,
      )
    }
    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        param.into(),
      )
    }
    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        params,
      )
    }
    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        params,
      )
    }
    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (
        id::Set,
        username::Set,
        access_token::Set,
        refresh_token::Set,
        expires_at::Set,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (id, username, access_token, refresh_token, expires_at, mut _params) = _create;
      _params.push(id.into());
      _params.push(username.into());
      _params.push(access_token.into());
      _params.push(refresh_token.into());
      _params.push(expires_at.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod modpack {
  use super::{_prisma::*, *};
  pub mod modpack_id {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ModpackIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ModpackId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModpackIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModpackIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ModpackIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ModpackIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ModpackIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ModpackIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ModpackIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ModpackIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ModpackIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ModpackIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetModpackId(value.0)
      }
    }
  }
  pub mod adapter {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::AdapterEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Adapter(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AdapterInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AdapterNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AdapterLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AdapterLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AdapterGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AdapterGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AdapterContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AdapterStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AdapterEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AdapterNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAdapter(value.0)
      }
    }
  }
  pub mod name {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::NameEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::NameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::NameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::NameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::NameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::NameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::NameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::NameEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::NameNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
  }
  pub mod path {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::PathEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Path(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::PathInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::PathNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::PathLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::PathLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::PathGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::PathGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::PathContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::PathStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::PathEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::PathNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetPath(value.0)
      }
    }
  }
  pub mod version {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::VersionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Version(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::VersionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::VersionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::VersionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::VersionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::VersionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::VersionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::VersionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::VersionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::VersionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::VersionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetVersion(value.0)
      }
    }
  }
  pub mod icon_url {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::IconUrlEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::IconUrl(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IconUrlInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IconUrlNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IconUrlLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IconUrlLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IconUrlGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IconUrlGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IconUrlContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IconUrlStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IconUrlEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IconUrlNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetIconUrl(value.0)
      }
    }
  }
  pub mod description {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::DescriptionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Description(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::DescriptionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::DescriptionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::DescriptionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::DescriptionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::DescriptionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::DescriptionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::DescriptionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::DescriptionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDescription(value.0)
      }
    }
  }
  pub mod description_format {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::DescriptionFormatEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::DescriptionFormat(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionFormatInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionFormatNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::DescriptionFormatLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::DescriptionFormatLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::DescriptionFormatGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::DescriptionFormatGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::DescriptionFormatContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::DescriptionFormatStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::DescriptionFormatEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::DescriptionFormatNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDescriptionFormat(value.0)
      }
    }
  }
  pub mod short_description {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ShortDescriptionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ShortDescription(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ShortDescriptionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ShortDescriptionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ShortDescriptionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ShortDescriptionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ShortDescriptionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ShortDescriptionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ShortDescriptionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ShortDescriptionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ShortDescriptionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ShortDescriptionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetShortDescription(value.0)
      }
    }
  }
  pub mod author {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::AuthorEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Author(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AuthorInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AuthorNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AuthorLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AuthorLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AuthorGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AuthorGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AuthorContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AuthorStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AuthorEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AuthorNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAuthor(value.0)
      }
    }
  }
  pub mod mods {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn some(value: Vec<mods_in_modpack::WhereParam>) -> WhereParam {
      WhereParam::ModsSome(value)
    }
    pub fn every(value: Vec<mods_in_modpack::WhereParam>) -> WhereParam {
      WhereParam::ModsEvery(value)
    }
    pub fn none(value: Vec<mods_in_modpack::WhereParam>) -> WhereParam {
      WhereParam::ModsNone(value)
    }
    pub struct Fetch {
      args: mods_in_modpack::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<mods_in_modpack::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
      pub fn order_by(mut self, param: mods_in_modpack::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }
      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }
      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }
      pub fn cursor(mut self, value: impl Into<mods_in_modpack::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Mods(fetch.args)
      }
    }
    pub fn fetch(params: Vec<mods_in_modpack::WhereParam>) -> Fetch {
      Fetch {
        args: mods_in_modpack::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<mods_in_modpack::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<mods_in_modpack::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkMods(params)
    }
    pub struct Link(Vec<mods_in_modpack::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkMods(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    [
      "modpackId",
      "adapter",
      "name",
      "path",
      "version",
      "iconUrl",
      "description",
      "descriptionFormat",
      "shortDescription",
      "author",
    ]
    .into_iter()
    .map(|o| {
      let builder = Selection::builder(o);
      builder.build()
    })
    .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "modpackId")]
    pub modpack_id: String,
    #[serde(rename = "adapter")]
    pub adapter: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "path")]
    pub path: String,
    #[serde(rename = "version")]
    pub version: String,
    #[serde(rename = "iconUrl")]
    pub icon_url: String,
    #[serde(rename = "description")]
    pub description: String,
    #[serde(rename = "descriptionFormat")]
    pub description_format: String,
    #[serde(rename = "shortDescription")]
    pub short_description: String,
    #[serde(rename = "author")]
    pub author: String,
    #[serde(rename = "mods")]
    pub mods: Option<Vec<super::mods_in_modpack::Data>>,
  }
  impl Data {
    pub fn mods(&self) -> Result<&Vec<super::mods_in_modpack::Data>, &'static str> {
      self
        .mods
        .as_ref()
        .ok_or("Attempted to access 'mods' but did not fetch it using the .with() syntax")
    }
  }
  pub enum WithParam {
    Mods(super::mods_in_modpack::ManyArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::Mods(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::mods_in_modpack::_outputs());
          let mut builder = Selection::builder("mods");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetModpackId(String),
    SetAdapter(String),
    SetName(String),
    SetPath(String),
    SetVersion(String),
    SetIconUrl(String),
    SetDescription(String),
    SetDescriptionFormat(String),
    SetShortDescription(String),
    SetAuthor(String),
    LinkMods(Vec<super::mods_in_modpack::UniqueWhereParam>),
    UnlinkMods(Vec<super::mods_in_modpack::UniqueWhereParam>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetModpackId(value) => ("modpackId".to_string(), PrismaValue::String(value)),
        SetParam::SetAdapter(value) => ("adapter".to_string(), PrismaValue::String(value)),
        SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
        SetParam::SetPath(value) => ("path".to_string(), PrismaValue::String(value)),
        SetParam::SetVersion(value) => ("version".to_string(), PrismaValue::String(value)),
        SetParam::SetIconUrl(value) => ("iconUrl".to_string(), PrismaValue::String(value)),
        SetParam::SetDescription(value) => ("description".to_string(), PrismaValue::String(value)),
        SetParam::SetDescriptionFormat(value) => {
          ("descriptionFormat".to_string(), PrismaValue::String(value))
        }
        SetParam::SetShortDescription(value) => {
          ("shortDescription".to_string(), PrismaValue::String(value))
        }
        SetParam::SetAuthor(value) => ("author".to_string(), PrismaValue::String(value)),
        SetParam::LinkMods(where_params) => (
          "mods".to_string(),
          PrismaValue::Object(vec![(
            "connect".to_string(),
            PrismaValue::Object(transform_equals(
              where_params
                .into_iter()
                .map(Into::<super::mods_in_modpack::WhereParam>::into),
            )),
          )]),
        ),
        SetParam::UnlinkMods(where_params) => (
          "mods".to_string(),
          PrismaValue::Object(vec![(
            "disconnect".to_string(),
            PrismaValue::Object(
              transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::mods_in_modpack::WhereParam>::into),
              )
              .into_iter()
              .collect(),
            ),
          )]),
        ),
      }
    }
  }
  pub enum OrderByParam {
    ModpackId(Direction),
    Adapter(Direction),
    Name(Direction),
    Path(Direction),
    Version(Direction),
    IconUrl(Direction),
    Description(Direction),
    DescriptionFormat(Direction),
    ShortDescription(Direction),
    Author(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::ModpackId(direction) => (
          "modpackId".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Adapter(direction) => (
          "adapter".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          "name".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Path(direction) => (
          "path".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Version(direction) => (
          "version".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::IconUrl(direction) => (
          "iconUrl".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Description(direction) => (
          "description".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::DescriptionFormat(direction) => (
          "descriptionFormat".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::ShortDescription(direction) => (
          "shortDescription".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Author(direction) => (
          "author".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  pub enum Cursor {}
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {}
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    ModpackIdEquals(String),
    ModpackIdInVec(Vec<String>),
    ModpackIdNotInVec(Vec<String>),
    ModpackIdLt(String),
    ModpackIdLte(String),
    ModpackIdGt(String),
    ModpackIdGte(String),
    ModpackIdContains(String),
    ModpackIdStartsWith(String),
    ModpackIdEndsWith(String),
    ModpackIdNot(String),
    AdapterEquals(String),
    AdapterInVec(Vec<String>),
    AdapterNotInVec(Vec<String>),
    AdapterLt(String),
    AdapterLte(String),
    AdapterGt(String),
    AdapterGte(String),
    AdapterContains(String),
    AdapterStartsWith(String),
    AdapterEndsWith(String),
    AdapterNot(String),
    NameEquals(String),
    NameInVec(Vec<String>),
    NameNotInVec(Vec<String>),
    NameLt(String),
    NameLte(String),
    NameGt(String),
    NameGte(String),
    NameContains(String),
    NameStartsWith(String),
    NameEndsWith(String),
    NameNot(String),
    PathEquals(String),
    PathInVec(Vec<String>),
    PathNotInVec(Vec<String>),
    PathLt(String),
    PathLte(String),
    PathGt(String),
    PathGte(String),
    PathContains(String),
    PathStartsWith(String),
    PathEndsWith(String),
    PathNot(String),
    VersionEquals(String),
    VersionInVec(Vec<String>),
    VersionNotInVec(Vec<String>),
    VersionLt(String),
    VersionLte(String),
    VersionGt(String),
    VersionGte(String),
    VersionContains(String),
    VersionStartsWith(String),
    VersionEndsWith(String),
    VersionNot(String),
    IconUrlEquals(String),
    IconUrlInVec(Vec<String>),
    IconUrlNotInVec(Vec<String>),
    IconUrlLt(String),
    IconUrlLte(String),
    IconUrlGt(String),
    IconUrlGte(String),
    IconUrlContains(String),
    IconUrlStartsWith(String),
    IconUrlEndsWith(String),
    IconUrlNot(String),
    DescriptionEquals(String),
    DescriptionInVec(Vec<String>),
    DescriptionNotInVec(Vec<String>),
    DescriptionLt(String),
    DescriptionLte(String),
    DescriptionGt(String),
    DescriptionGte(String),
    DescriptionContains(String),
    DescriptionStartsWith(String),
    DescriptionEndsWith(String),
    DescriptionNot(String),
    DescriptionFormatEquals(String),
    DescriptionFormatInVec(Vec<String>),
    DescriptionFormatNotInVec(Vec<String>),
    DescriptionFormatLt(String),
    DescriptionFormatLte(String),
    DescriptionFormatGt(String),
    DescriptionFormatGte(String),
    DescriptionFormatContains(String),
    DescriptionFormatStartsWith(String),
    DescriptionFormatEndsWith(String),
    DescriptionFormatNot(String),
    ShortDescriptionEquals(String),
    ShortDescriptionInVec(Vec<String>),
    ShortDescriptionNotInVec(Vec<String>),
    ShortDescriptionLt(String),
    ShortDescriptionLte(String),
    ShortDescriptionGt(String),
    ShortDescriptionGte(String),
    ShortDescriptionContains(String),
    ShortDescriptionStartsWith(String),
    ShortDescriptionEndsWith(String),
    ShortDescriptionNot(String),
    AuthorEquals(String),
    AuthorInVec(Vec<String>),
    AuthorNotInVec(Vec<String>),
    AuthorLt(String),
    AuthorLte(String),
    AuthorGt(String),
    AuthorGte(String),
    AuthorContains(String),
    AuthorStartsWith(String),
    AuthorEndsWith(String),
    AuthorNot(String),
    ModsSome(Vec<super::mods_in_modpack::WhereParam>),
    ModsEvery(Vec<super::mods_in_modpack::WhereParam>),
    ModsNone(Vec<super::mods_in_modpack::WhereParam>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => (
          "NOT".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::Or(value) => (
          "OR".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::ModpackIdEquals(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdInVec(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModpackIdNotInVec(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModpackIdLt(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdLte(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdGt(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdGte(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdContains(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdStartsWith(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ModpackIdEndsWith(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdNot(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterEquals(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterInVec(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AdapterNotInVec(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AdapterLt(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterLte(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterGt(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterGte(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterContains(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterStartsWith(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::AdapterEndsWith(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterNot(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameEquals(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameInVec(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::NameNotInVec(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::NameLt(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameLte(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameGt(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameGte(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameContains(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameStartsWith(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::NameEndsWith(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameNot(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathEquals(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathInVec(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::PathNotInVec(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::PathLt(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathLte(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathGt(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathGte(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathContains(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathStartsWith(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::PathEndsWith(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::PathNot(value) => (
          "path".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionEquals(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionInVec(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::VersionNotInVec(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::VersionLt(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionLte(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionGt(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionGte(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionContains(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionStartsWith(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::VersionEndsWith(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionNot(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlEquals(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlInVec(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::IconUrlNotInVec(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::IconUrlLt(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlLte(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlGt(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlGte(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlContains(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlStartsWith(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::IconUrlEndsWith(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::IconUrlNot(value) => (
          "iconUrl".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionEquals(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionInVec(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionNotInVec(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionLt(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionLte(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionGt(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionGte(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionContains(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionStartsWith(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::DescriptionEndsWith(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionNot(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatEquals(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatInVec(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionFormatNotInVec(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionFormatLt(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatLte(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatGt(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatGte(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatContains(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatStartsWith(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::DescriptionFormatEndsWith(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatNot(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionEquals(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionInVec(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ShortDescriptionNotInVec(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ShortDescriptionLt(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionLte(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionGt(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionGte(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionContains(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionStartsWith(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ShortDescriptionEndsWith(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionNot(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorEquals(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorInVec(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AuthorNotInVec(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AuthorLt(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorLte(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorGt(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorGte(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorContains(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorStartsWith(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::AuthorEndsWith(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorNot(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModsSome(value) => (
          "mods".to_string(),
          SerializedWhereValue::Object(vec![(
            "some".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModsEvery(value) => (
          "mods".to_string(),
          SerializedWhereValue::Object(vec![(
            "every".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModsNone(value) => (
          "mods".to_string(),
          SerializedWhereValue::Object(vec![(
            "none".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
      }
    }
  }
  pub enum UniqueWhereParam {}
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {}
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      modpack_id: modpack_id::Set,
      adapter: adapter::Set,
      name: name::Set,
      path: path::Set,
      version: version::Set,
      icon_url: icon_url::Set,
      description: description::Set,
      description_format: description_format::Set,
      short_description: short_description::Set,
      author: author::Set,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(modpack_id.into());
      _params.push(adapter.into());
      _params.push(name.into());
      _params.push(path.into());
      _params.push(version.into());
      _params.push(icon_url.into());
      _params.push(description.into());
      _params.push(description_format.into());
      _params.push(short_description.into());
      _params.push(author.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("Modpack", _outputs()),
        _params,
      )
    }
    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("Modpack", _outputs()),
        param.into(),
      )
    }
    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("Modpack", _outputs()),
        params,
      )
    }
    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("Modpack", _outputs()),
        params,
      )
    }
    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (
        modpack_id::Set,
        adapter::Set,
        name::Set,
        path::Set,
        version::Set,
        icon_url::Set,
        description::Set,
        description_format::Set,
        short_description::Set,
        author::Set,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (
        modpack_id,
        adapter,
        name,
        path,
        version,
        icon_url,
        description,
        description_format,
        short_description,
        author,
        mut _params,
      ) = _create;
      _params.push(modpack_id.into());
      _params.push(adapter.into());
      _params.push(name.into());
      _params.push(path.into());
      _params.push(version.into());
      _params.push(icon_url.into());
      _params.push(description.into());
      _params.push(description_format.into());
      _params.push(short_description.into());
      _params.push(author.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("Modpack", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod minecraft_mod {
  use super::{_prisma::*, *};
  pub mod mod_id {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ModIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ModId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ModIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ModIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ModIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ModIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ModIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ModIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ModIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ModIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetModId(value.0)
      }
    }
  }
  pub mod adapter {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::AdapterEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Adapter(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AdapterInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AdapterNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AdapterLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AdapterLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AdapterGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AdapterGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AdapterContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AdapterStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AdapterEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AdapterNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAdapter(value.0)
      }
    }
  }
  pub mod name {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::NameEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::NameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::NameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::NameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::NameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::NameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::NameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::NameEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::NameNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
  }
  pub mod version {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::VersionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Version(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::VersionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::VersionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::VersionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::VersionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::VersionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::VersionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::VersionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::VersionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::VersionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::VersionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetVersion(value.0)
      }
    }
  }
  pub mod file {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::FileEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::File(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::FileInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::FileNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::FileLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::FileLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::FileGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::FileGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::FileContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::FileStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::FileEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::FileNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetFile(value.0)
      }
    }
  }
  pub mod description {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::DescriptionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Description(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::DescriptionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::DescriptionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::DescriptionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::DescriptionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::DescriptionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::DescriptionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::DescriptionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::DescriptionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDescription(value.0)
      }
    }
  }
  pub mod description_format {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::DescriptionFormatEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::DescriptionFormat(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionFormatInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionFormatNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::DescriptionFormatLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::DescriptionFormatLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::DescriptionFormatGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::DescriptionFormatGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::DescriptionFormatContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::DescriptionFormatStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::DescriptionFormatEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::DescriptionFormatNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDescriptionFormat(value.0)
      }
    }
  }
  pub mod short_description {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ShortDescriptionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ShortDescription(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ShortDescriptionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ShortDescriptionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ShortDescriptionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ShortDescriptionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ShortDescriptionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ShortDescriptionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ShortDescriptionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ShortDescriptionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ShortDescriptionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ShortDescriptionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetShortDescription(value.0)
      }
    }
  }
  pub mod author {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::AuthorEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Author(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AuthorInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AuthorNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AuthorLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AuthorLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AuthorGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AuthorGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AuthorContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AuthorStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AuthorEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AuthorNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAuthor(value.0)
      }
    }
  }
  pub mod modpack {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn some(value: Vec<mods_in_modpack::WhereParam>) -> WhereParam {
      WhereParam::ModpackSome(value)
    }
    pub fn every(value: Vec<mods_in_modpack::WhereParam>) -> WhereParam {
      WhereParam::ModpackEvery(value)
    }
    pub fn none(value: Vec<mods_in_modpack::WhereParam>) -> WhereParam {
      WhereParam::ModpackNone(value)
    }
    pub struct Fetch {
      args: mods_in_modpack::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<mods_in_modpack::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
      pub fn order_by(mut self, param: mods_in_modpack::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }
      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }
      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }
      pub fn cursor(mut self, value: impl Into<mods_in_modpack::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Modpack(fetch.args)
      }
    }
    pub fn fetch(params: Vec<mods_in_modpack::WhereParam>) -> Fetch {
      Fetch {
        args: mods_in_modpack::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<mods_in_modpack::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<mods_in_modpack::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkModpack(params)
    }
    pub struct Link(Vec<mods_in_modpack::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkModpack(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    [
      "modId",
      "adapter",
      "name",
      "version",
      "file",
      "description",
      "descriptionFormat",
      "shortDescription",
      "author",
    ]
    .into_iter()
    .map(|o| {
      let builder = Selection::builder(o);
      builder.build()
    })
    .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "modId")]
    pub mod_id: String,
    #[serde(rename = "adapter")]
    pub adapter: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "version")]
    pub version: String,
    #[serde(rename = "file")]
    pub file: String,
    #[serde(rename = "description")]
    pub description: String,
    #[serde(rename = "descriptionFormat")]
    pub description_format: String,
    #[serde(rename = "shortDescription")]
    pub short_description: String,
    #[serde(rename = "author")]
    pub author: String,
    #[serde(rename = "modpack")]
    pub modpack: Option<Vec<super::mods_in_modpack::Data>>,
  }
  impl Data {
    pub fn modpack(&self) -> Result<&Vec<super::mods_in_modpack::Data>, &'static str> {
      self
        .modpack
        .as_ref()
        .ok_or("Attempted to access 'modpack' but did not fetch it using the .with() syntax")
    }
  }
  pub enum WithParam {
    Modpack(super::mods_in_modpack::ManyArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::Modpack(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::mods_in_modpack::_outputs());
          let mut builder = Selection::builder("modpack");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetModId(String),
    SetAdapter(String),
    SetName(String),
    SetVersion(String),
    SetFile(String),
    SetDescription(String),
    SetDescriptionFormat(String),
    SetShortDescription(String),
    SetAuthor(String),
    LinkModpack(Vec<super::mods_in_modpack::UniqueWhereParam>),
    UnlinkModpack(Vec<super::mods_in_modpack::UniqueWhereParam>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetModId(value) => ("modId".to_string(), PrismaValue::String(value)),
        SetParam::SetAdapter(value) => ("adapter".to_string(), PrismaValue::String(value)),
        SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
        SetParam::SetVersion(value) => ("version".to_string(), PrismaValue::String(value)),
        SetParam::SetFile(value) => ("file".to_string(), PrismaValue::String(value)),
        SetParam::SetDescription(value) => ("description".to_string(), PrismaValue::String(value)),
        SetParam::SetDescriptionFormat(value) => {
          ("descriptionFormat".to_string(), PrismaValue::String(value))
        }
        SetParam::SetShortDescription(value) => {
          ("shortDescription".to_string(), PrismaValue::String(value))
        }
        SetParam::SetAuthor(value) => ("author".to_string(), PrismaValue::String(value)),
        SetParam::LinkModpack(where_params) => (
          "modpack".to_string(),
          PrismaValue::Object(vec![(
            "connect".to_string(),
            PrismaValue::Object(transform_equals(
              where_params
                .into_iter()
                .map(Into::<super::mods_in_modpack::WhereParam>::into),
            )),
          )]),
        ),
        SetParam::UnlinkModpack(where_params) => (
          "modpack".to_string(),
          PrismaValue::Object(vec![(
            "disconnect".to_string(),
            PrismaValue::Object(
              transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::mods_in_modpack::WhereParam>::into),
              )
              .into_iter()
              .collect(),
            ),
          )]),
        ),
      }
    }
  }
  pub enum OrderByParam {
    ModId(Direction),
    Adapter(Direction),
    Name(Direction),
    Version(Direction),
    File(Direction),
    Description(Direction),
    DescriptionFormat(Direction),
    ShortDescription(Direction),
    Author(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::ModId(direction) => (
          "modId".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Adapter(direction) => (
          "adapter".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          "name".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Version(direction) => (
          "version".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::File(direction) => (
          "file".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Description(direction) => (
          "description".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::DescriptionFormat(direction) => (
          "descriptionFormat".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::ShortDescription(direction) => (
          "shortDescription".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::Author(direction) => (
          "author".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  pub enum Cursor {}
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {}
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    ModIdEquals(String),
    ModIdInVec(Vec<String>),
    ModIdNotInVec(Vec<String>),
    ModIdLt(String),
    ModIdLte(String),
    ModIdGt(String),
    ModIdGte(String),
    ModIdContains(String),
    ModIdStartsWith(String),
    ModIdEndsWith(String),
    ModIdNot(String),
    AdapterEquals(String),
    AdapterInVec(Vec<String>),
    AdapterNotInVec(Vec<String>),
    AdapterLt(String),
    AdapterLte(String),
    AdapterGt(String),
    AdapterGte(String),
    AdapterContains(String),
    AdapterStartsWith(String),
    AdapterEndsWith(String),
    AdapterNot(String),
    NameEquals(String),
    NameInVec(Vec<String>),
    NameNotInVec(Vec<String>),
    NameLt(String),
    NameLte(String),
    NameGt(String),
    NameGte(String),
    NameContains(String),
    NameStartsWith(String),
    NameEndsWith(String),
    NameNot(String),
    VersionEquals(String),
    VersionInVec(Vec<String>),
    VersionNotInVec(Vec<String>),
    VersionLt(String),
    VersionLte(String),
    VersionGt(String),
    VersionGte(String),
    VersionContains(String),
    VersionStartsWith(String),
    VersionEndsWith(String),
    VersionNot(String),
    FileEquals(String),
    FileInVec(Vec<String>),
    FileNotInVec(Vec<String>),
    FileLt(String),
    FileLte(String),
    FileGt(String),
    FileGte(String),
    FileContains(String),
    FileStartsWith(String),
    FileEndsWith(String),
    FileNot(String),
    DescriptionEquals(String),
    DescriptionInVec(Vec<String>),
    DescriptionNotInVec(Vec<String>),
    DescriptionLt(String),
    DescriptionLte(String),
    DescriptionGt(String),
    DescriptionGte(String),
    DescriptionContains(String),
    DescriptionStartsWith(String),
    DescriptionEndsWith(String),
    DescriptionNot(String),
    DescriptionFormatEquals(String),
    DescriptionFormatInVec(Vec<String>),
    DescriptionFormatNotInVec(Vec<String>),
    DescriptionFormatLt(String),
    DescriptionFormatLte(String),
    DescriptionFormatGt(String),
    DescriptionFormatGte(String),
    DescriptionFormatContains(String),
    DescriptionFormatStartsWith(String),
    DescriptionFormatEndsWith(String),
    DescriptionFormatNot(String),
    ShortDescriptionEquals(String),
    ShortDescriptionInVec(Vec<String>),
    ShortDescriptionNotInVec(Vec<String>),
    ShortDescriptionLt(String),
    ShortDescriptionLte(String),
    ShortDescriptionGt(String),
    ShortDescriptionGte(String),
    ShortDescriptionContains(String),
    ShortDescriptionStartsWith(String),
    ShortDescriptionEndsWith(String),
    ShortDescriptionNot(String),
    AuthorEquals(String),
    AuthorInVec(Vec<String>),
    AuthorNotInVec(Vec<String>),
    AuthorLt(String),
    AuthorLte(String),
    AuthorGt(String),
    AuthorGte(String),
    AuthorContains(String),
    AuthorStartsWith(String),
    AuthorEndsWith(String),
    AuthorNot(String),
    ModpackSome(Vec<super::mods_in_modpack::WhereParam>),
    ModpackEvery(Vec<super::mods_in_modpack::WhereParam>),
    ModpackNone(Vec<super::mods_in_modpack::WhereParam>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => (
          "NOT".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::Or(value) => (
          "OR".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::ModIdEquals(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdInVec(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModIdNotInVec(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModIdLt(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdLte(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdGt(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdGte(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdContains(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdStartsWith(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ModIdEndsWith(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdNot(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterEquals(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterInVec(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AdapterNotInVec(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AdapterLt(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterLte(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterGt(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterGte(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterContains(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterStartsWith(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::AdapterEndsWith(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::AdapterNot(value) => (
          "adapter".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameEquals(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameInVec(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::NameNotInVec(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::NameLt(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameLte(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameGt(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameGte(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameContains(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameStartsWith(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::NameEndsWith(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::NameNot(value) => (
          "name".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionEquals(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionInVec(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::VersionNotInVec(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::VersionLt(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionLte(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionGt(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionGte(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionContains(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionStartsWith(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::VersionEndsWith(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::VersionNot(value) => (
          "version".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileEquals(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileInVec(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::FileNotInVec(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::FileLt(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileLte(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileGt(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileGte(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileContains(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileStartsWith(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::FileEndsWith(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::FileNot(value) => (
          "file".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionEquals(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionInVec(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionNotInVec(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionLt(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionLte(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionGt(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionGte(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionContains(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionStartsWith(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::DescriptionEndsWith(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionNot(value) => (
          "description".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatEquals(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatInVec(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionFormatNotInVec(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::DescriptionFormatLt(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatLte(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatGt(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatGte(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatContains(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatStartsWith(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::DescriptionFormatEndsWith(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::DescriptionFormatNot(value) => (
          "descriptionFormat".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionEquals(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionInVec(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ShortDescriptionNotInVec(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ShortDescriptionLt(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionLte(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionGt(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionGte(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionContains(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionStartsWith(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ShortDescriptionEndsWith(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ShortDescriptionNot(value) => (
          "shortDescription".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorEquals(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorInVec(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AuthorNotInVec(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::AuthorLt(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorLte(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorGt(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorGte(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorContains(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorStartsWith(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::AuthorEndsWith(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::AuthorNot(value) => (
          "author".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackSome(value) => (
          "modpack".to_string(),
          SerializedWhereValue::Object(vec![(
            "some".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModpackEvery(value) => (
          "modpack".to_string(),
          SerializedWhereValue::Object(vec![(
            "every".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModpackNone(value) => (
          "modpack".to_string(),
          SerializedWhereValue::Object(vec![(
            "none".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
      }
    }
  }
  pub enum UniqueWhereParam {}
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {}
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      mod_id: mod_id::Set,
      adapter: adapter::Set,
      name: name::Set,
      version: version::Set,
      file: file::Set,
      description: description::Set,
      description_format: description_format::Set,
      short_description: short_description::Set,
      author: author::Set,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(mod_id.into());
      _params.push(adapter.into());
      _params.push(name.into());
      _params.push(version.into());
      _params.push(file.into());
      _params.push(description.into());
      _params.push(description_format.into());
      _params.push(short_description.into());
      _params.push(author.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("MinecraftMod", _outputs()),
        _params,
      )
    }
    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("MinecraftMod", _outputs()),
        param.into(),
      )
    }
    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("MinecraftMod", _outputs()),
        params,
      )
    }
    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("MinecraftMod", _outputs()),
        params,
      )
    }
    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (
        mod_id::Set,
        adapter::Set,
        name::Set,
        version::Set,
        file::Set,
        description::Set,
        description_format::Set,
        short_description::Set,
        author::Set,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (
        mod_id,
        adapter,
        name,
        version,
        file,
        description,
        description_format,
        short_description,
        author,
        mut _params,
      ) = _create;
      _params.push(mod_id.into());
      _params.push(adapter.into());
      _params.push(name.into());
      _params.push(version.into());
      _params.push(file.into());
      _params.push(description.into());
      _params.push(description_format.into());
      _params.push(short_description.into());
      _params.push(author.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("MinecraftMod", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod mods_in_modpack {
  use super::{_prisma::*, *};
  pub mod minecraft_mod {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn is(value: Vec<minecraft_mod::WhereParam>) -> WhereParam {
      WhereParam::MinecraftModIs(value)
    }
    pub fn is_not(value: Vec<minecraft_mod::WhereParam>) -> WhereParam {
      WhereParam::MinecraftModIsNot(value)
    }
    pub struct Fetch {
      args: minecraft_mod::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<minecraft_mod::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::MinecraftMod(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: minecraft_mod::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: minecraft_mod::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkMinecraftMod
    }
    pub struct Link(minecraft_mod::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkMinecraftMod(value.0)
      }
    }
  }
  pub mod mod_id {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ModIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ModId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ModIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ModIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ModIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ModIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ModIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ModIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ModIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ModIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetModId(value.0)
      }
    }
  }
  pub mod mod_adapter {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ModAdapterEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ModAdapter(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModAdapterInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModAdapterNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ModAdapterLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ModAdapterLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ModAdapterGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ModAdapterGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ModAdapterContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ModAdapterStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ModAdapterEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ModAdapterNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetModAdapter(value.0)
      }
    }
  }
  pub mod modpack {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn is(value: Vec<modpack::WhereParam>) -> WhereParam {
      WhereParam::ModpackIs(value)
    }
    pub fn is_not(value: Vec<modpack::WhereParam>) -> WhereParam {
      WhereParam::ModpackIsNot(value)
    }
    pub struct Fetch {
      args: modpack::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<modpack::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Modpack(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: modpack::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: modpack::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkModpack
    }
    pub struct Link(modpack::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkModpack(value.0)
      }
    }
  }
  pub mod modpack_id {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ModpackIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ModpackId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModpackIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModpackIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ModpackIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ModpackIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ModpackIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ModpackIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ModpackIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ModpackIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ModpackIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ModpackIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetModpackId(value.0)
      }
    }
  }
  pub mod modpack_adapter {
    use super::{
      super::*, Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam, _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ModpackAdapterEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ModpackAdapter(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModpackAdapterInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ModpackAdapterNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ModpackAdapterLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ModpackAdapterLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ModpackAdapterGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ModpackAdapterGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ModpackAdapterContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ModpackAdapterStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ModpackAdapterEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ModpackAdapterNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetModpackAdapter(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    ["modId", "modAdapter", "modpackId", "modpackAdapter"]
      .into_iter()
      .map(|o| {
        let builder = Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "minecraftMod")]
    pub minecraft_mod: Option<Box<super::minecraft_mod::Data>>,
    #[serde(rename = "modId")]
    pub mod_id: String,
    #[serde(rename = "modAdapter")]
    pub mod_adapter: String,
    #[serde(rename = "Modpack")]
    pub modpack: Option<Box<super::modpack::Data>>,
    #[serde(rename = "modpackId")]
    pub modpack_id: String,
    #[serde(rename = "modpackAdapter")]
    pub modpack_adapter: String,
  }
  impl Data {
    pub fn minecraft_mod(&self) -> Result<&super::minecraft_mod::Data, &'static str> {
      self
        .minecraft_mod
        .as_ref()
        .ok_or("Attempted to access 'minecraft_mod' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }
    pub fn modpack(&self) -> Result<&super::modpack::Data, &'static str> {
      self
        .modpack
        .as_ref()
        .ok_or("Attempted to access 'modpack' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }
  }
  pub enum WithParam {
    MinecraftMod(super::minecraft_mod::UniqueArgs),
    Modpack(super::modpack::UniqueArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::MinecraftMod(args) => {
          let mut selections = super::minecraft_mod::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("minecraftMod");
          builder.nested_selections(selections);
          builder.build()
        }
        Self::Modpack(args) => {
          let mut selections = super::modpack::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("Modpack");
          builder.nested_selections(selections);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    LinkMinecraftMod(super::minecraft_mod::UniqueWhereParam),
    UnlinkMinecraftMod,
    SetModId(String),
    SetModAdapter(String),
    LinkModpack(super::modpack::UniqueWhereParam),
    UnlinkModpack,
    SetModpackId(String),
    SetModpackAdapter(String),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::LinkMinecraftMod(where_param) => (
          "minecraftMod".to_string(),
          PrismaValue::Object(vec![(
            "connect".to_string(),
            PrismaValue::Object(transform_equals(
              vec![Into::<super::minecraft_mod::WhereParam>::into(where_param)].into_iter(),
            )),
          )]),
        ),
        SetParam::UnlinkMinecraftMod => (
          "minecraftMod".to_string(),
          PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
        ),
        SetParam::SetModId(value) => ("modId".to_string(), PrismaValue::String(value)),
        SetParam::SetModAdapter(value) => ("modAdapter".to_string(), PrismaValue::String(value)),
        SetParam::LinkModpack(where_param) => (
          "Modpack".to_string(),
          PrismaValue::Object(vec![(
            "connect".to_string(),
            PrismaValue::Object(transform_equals(
              vec![Into::<super::modpack::WhereParam>::into(where_param)].into_iter(),
            )),
          )]),
        ),
        SetParam::UnlinkModpack => (
          "Modpack".to_string(),
          PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
        ),
        SetParam::SetModpackId(value) => ("modpackId".to_string(), PrismaValue::String(value)),
        SetParam::SetModpackAdapter(value) => {
          ("modpackAdapter".to_string(), PrismaValue::String(value))
        }
      }
    }
  }
  pub enum OrderByParam {
    ModId(Direction),
    ModAdapter(Direction),
    ModpackId(Direction),
    ModpackAdapter(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::ModId(direction) => (
          "modId".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::ModAdapter(direction) => (
          "modAdapter".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::ModpackId(direction) => (
          "modpackId".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
        Self::ModpackAdapter(direction) => (
          "modpackAdapter".to_string(),
          PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  pub enum Cursor {}
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {}
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    MinecraftModIs(Vec<super::minecraft_mod::WhereParam>),
    MinecraftModIsNot(Vec<super::minecraft_mod::WhereParam>),
    ModIdEquals(String),
    ModIdInVec(Vec<String>),
    ModIdNotInVec(Vec<String>),
    ModIdLt(String),
    ModIdLte(String),
    ModIdGt(String),
    ModIdGte(String),
    ModIdContains(String),
    ModIdStartsWith(String),
    ModIdEndsWith(String),
    ModIdNot(String),
    ModAdapterEquals(String),
    ModAdapterInVec(Vec<String>),
    ModAdapterNotInVec(Vec<String>),
    ModAdapterLt(String),
    ModAdapterLte(String),
    ModAdapterGt(String),
    ModAdapterGte(String),
    ModAdapterContains(String),
    ModAdapterStartsWith(String),
    ModAdapterEndsWith(String),
    ModAdapterNot(String),
    ModpackIs(Vec<super::modpack::WhereParam>),
    ModpackIsNot(Vec<super::modpack::WhereParam>),
    ModpackIdEquals(String),
    ModpackIdInVec(Vec<String>),
    ModpackIdNotInVec(Vec<String>),
    ModpackIdLt(String),
    ModpackIdLte(String),
    ModpackIdGt(String),
    ModpackIdGte(String),
    ModpackIdContains(String),
    ModpackIdStartsWith(String),
    ModpackIdEndsWith(String),
    ModpackIdNot(String),
    ModpackAdapterEquals(String),
    ModpackAdapterInVec(Vec<String>),
    ModpackAdapterNotInVec(Vec<String>),
    ModpackAdapterLt(String),
    ModpackAdapterLte(String),
    ModpackAdapterGt(String),
    ModpackAdapterGte(String),
    ModpackAdapterContains(String),
    ModpackAdapterStartsWith(String),
    ModpackAdapterEndsWith(String),
    ModpackAdapterNot(String),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => (
          "NOT".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::Or(value) => (
          "OR".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND".to_string(),
          SerializedWhereValue::List(
            value
              .into_iter()
              .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
              .collect(),
          ),
        ),
        Self::MinecraftModIs(value) => (
          "minecraftMod".to_string(),
          SerializedWhereValue::Object(vec![(
            "is".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::MinecraftModIsNot(value) => (
          "minecraftMod".to_string(),
          SerializedWhereValue::Object(vec![(
            "isNot".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModIdEquals(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdInVec(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModIdNotInVec(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModIdLt(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdLte(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdGt(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdGte(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdContains(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdStartsWith(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ModIdEndsWith(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModIdNot(value) => (
          "modId".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterEquals(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterInVec(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModAdapterNotInVec(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModAdapterLt(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterLte(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterGt(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterGte(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterContains(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterStartsWith(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ModAdapterEndsWith(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModAdapterNot(value) => (
          "modAdapter".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIs(value) => (
          "Modpack".to_string(),
          SerializedWhereValue::Object(vec![(
            "is".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModpackIsNot(value) => (
          "Modpack".to_string(),
          SerializedWhereValue::Object(vec![(
            "isNot".to_string(),
            PrismaValue::Object(transform_equals(
              value.into_iter().map(Into::<SerializedWhere>::into),
            )),
          )]),
        ),
        Self::ModpackIdEquals(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdInVec(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModpackIdNotInVec(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModpackIdLt(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdLte(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdGt(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdGte(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdContains(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdStartsWith(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ModpackIdEndsWith(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackIdNot(value) => (
          "modpackId".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterEquals(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterInVec(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "in".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModpackAdapterNotInVec(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
          )]),
        ),
        Self::ModpackAdapterLt(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterLte(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterGt(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterGte(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterContains(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("contains".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterStartsWith(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            PrismaValue::String(value),
          )]),
        ),
        Self::ModpackAdapterEndsWith(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("endsWith".to_string(), PrismaValue::String(value))]),
        ),
        Self::ModpackAdapterNot(value) => (
          "modpackAdapter".to_string(),
          SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
        ),
      }
    }
  }
  pub enum UniqueWhereParam {}
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {}
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      minecraft_mod: minecraft_mod::Link,
      modpack: modpack::Link,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(minecraft_mod.into());
      _params.push(modpack.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("ModsInModpack", _outputs()),
        _params,
      )
    }
    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("ModsInModpack", _outputs()),
        param.into(),
      )
    }
    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("ModsInModpack", _outputs()),
        params,
      )
    }
    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("ModsInModpack", _outputs()),
        params,
      )
    }
    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (minecraft_mod::Link, modpack::Link, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (minecraft_mod, modpack, mut _params) = _create;
      _params.push(minecraft_mod.into());
      _params.push(modpack.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("ModsInModpack", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod _prisma {
  use super::*;
  use prisma_client_rust::{
    queries::QueryContext,
    query_core::{QueryExecutor, QuerySchema},
    raw, ExecuteRaw, QueryRaw,
  };
  use serde::{Deserialize, Serialize};
  use std::{fmt, sync::Arc};
  pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
  }
  impl fmt::Debug for PrismaClient {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("PrismaClient").finish()
    }
  }
  impl PrismaClient {
    pub(super) fn _new_query_context(&self) -> QueryContext {
      QueryContext::new(&self.executor, self.query_schema.clone())
    }
    pub(super) fn _new(
      executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
      query_schema: Arc<QuerySchema>,
    ) -> Self {
      Self {
        executor,
        query_schema,
      }
    }
    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
      &self,
      query: raw::Raw,
    ) -> QueryResult<Vec<T>> {
      QueryRaw::new(
        QueryContext::new(&self.executor, self.query_schema.clone()),
        query,
        DATABASE_STR,
      )
      .exec()
      .await
    }
    pub async fn _execute_raw(&self, query: raw::Raw) -> QueryResult<i64> {
      ExecuteRaw::new(
        QueryContext::new(&self.executor, self.query_schema.clone()),
        query,
        DATABASE_STR,
      )
      .exec()
      .await
    }
    pub fn account(&self) -> account::Actions {
      account::Actions { client: &self }
    }
    pub fn modpack(&self) -> modpack::Actions {
      modpack::Actions { client: &self }
    }
    pub fn minecraft_mod(&self) -> minecraft_mod::Actions {
      minecraft_mod::Actions { client: &self }
    }
    pub fn mods_in_modpack(&self) -> mods_in_modpack::Actions {
      mods_in_modpack::Actions { client: &self }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum AccountScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "username")]
    Username,
    #[serde(rename = "accessToken")]
    AccessToken,
    #[serde(rename = "refreshToken")]
    RefreshToken,
    #[serde(rename = "expiresAt")]
    ExpiresAt,
    #[serde(rename = "lastRefreshed")]
    LastRefreshed,
  }
  impl ToString for AccountScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Username => "username".to_string(),
        Self::AccessToken => "accessToken".to_string(),
        Self::RefreshToken => "refreshToken".to_string(),
        Self::ExpiresAt => "expiresAt".to_string(),
        Self::LastRefreshed => "lastRefreshed".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum ModpackScalarFieldEnum {
    #[serde(rename = "modpackId")]
    ModpackId,
    #[serde(rename = "adapter")]
    Adapter,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "path")]
    Path,
    #[serde(rename = "version")]
    Version,
    #[serde(rename = "iconUrl")]
    IconUrl,
    #[serde(rename = "description")]
    Description,
    #[serde(rename = "descriptionFormat")]
    DescriptionFormat,
    #[serde(rename = "shortDescription")]
    ShortDescription,
    #[serde(rename = "author")]
    Author,
  }
  impl ToString for ModpackScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::ModpackId => "modpackId".to_string(),
        Self::Adapter => "adapter".to_string(),
        Self::Name => "name".to_string(),
        Self::Path => "path".to_string(),
        Self::Version => "version".to_string(),
        Self::IconUrl => "iconUrl".to_string(),
        Self::Description => "description".to_string(),
        Self::DescriptionFormat => "descriptionFormat".to_string(),
        Self::ShortDescription => "shortDescription".to_string(),
        Self::Author => "author".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum MinecraftModScalarFieldEnum {
    #[serde(rename = "modId")]
    ModId,
    #[serde(rename = "adapter")]
    Adapter,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "version")]
    Version,
    #[serde(rename = "file")]
    File,
    #[serde(rename = "description")]
    Description,
    #[serde(rename = "descriptionFormat")]
    DescriptionFormat,
    #[serde(rename = "shortDescription")]
    ShortDescription,
    #[serde(rename = "author")]
    Author,
  }
  impl ToString for MinecraftModScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::ModId => "modId".to_string(),
        Self::Adapter => "adapter".to_string(),
        Self::Name => "name".to_string(),
        Self::Version => "version".to_string(),
        Self::File => "file".to_string(),
        Self::Description => "description".to_string(),
        Self::DescriptionFormat => "descriptionFormat".to_string(),
        Self::ShortDescription => "shortDescription".to_string(),
        Self::Author => "author".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum ModsInModpackScalarFieldEnum {
    #[serde(rename = "modId")]
    ModId,
    #[serde(rename = "modAdapter")]
    ModAdapter,
    #[serde(rename = "modpackId")]
    ModpackId,
    #[serde(rename = "modpackAdapter")]
    ModpackAdapter,
  }
  impl ToString for ModsInModpackScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::ModId => "modId".to_string(),
        Self::ModAdapter => "modAdapter".to_string(),
        Self::ModpackId => "modpackId".to_string(),
        Self::ModpackAdapter => "modpackAdapter".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
  }
  impl ToString for SortOrder {
    fn to_string(&self) -> String {
      match self {
        Self::Asc => "asc".to_string(),
        Self::Desc => "desc".to_string(),
      }
    }
  }
}
pub use _prisma::PrismaClient;
